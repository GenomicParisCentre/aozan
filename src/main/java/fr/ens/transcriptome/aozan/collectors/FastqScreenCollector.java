/*
 *                  Aozan development code
 *
 * This code may be freely distributed and modified under the
 * terms of the GNU General Public License version 3 or later 
 * and CeCILL. This should be distributed with the code. If you 
 * do not have a copy, see:
 *
 *      http://www.gnu.org/licenses/gpl-3.0-standalone.html
 *      http://www.cecill.info/licences/Licence_CeCILL_V2-en.html
 *
 * Copyright for this code is held jointly by the Genomic platform
 * of the Institut de Biologie de l'École Normale Supérieure and
 * the individual authors. These should be listed in @author doc
 * comments.
 *
 * For more information on the Aozan project and its aims,
 * or to join the Aozan Google group, visit the home page at:
 *
 *      http://www.transcriptome.ens.fr/aozan
 *
 */

package fr.ens.transcriptome.aozan.collectors;

import static fr.ens.transcriptome.eoulsan.util.StringUtils.toTimeHumanReadable;

import java.io.File;
import java.io.FileFilter;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.logging.Logger;

import com.google.common.base.Splitter;
import com.google.common.collect.Lists;

import fr.ens.transcriptome.aozan.AozanException;
import fr.ens.transcriptome.aozan.RunData;
import fr.ens.transcriptome.aozan.fastqscreen.FastqScreen;
import fr.ens.transcriptome.aozan.fastqscreen.FastqScreenResult;
import fr.ens.transcriptome.aozan.io.FastqStorage;
import fr.ens.transcriptome.eoulsan.Globals;

/**
 * This class manages the execution of Fastq Screen for a full run according to
 * the properties defined in the configuration file Aozan, which define the list
 * of references genomes. All results are stored in an object Rundata.
 * @author Sandrine Perrin
 */
public class FastqScreenCollector implements Collector {

  /** Logger */
  private static final Logger LOGGER = Logger.getLogger(Globals.APP_NAME);

  public static final String COLLECTOR_NAME = "fastqscreen";

  private static final String KEY_GENOMES = "qc.fastqscreen.genomes";
  private static final String KEY_FASTQ_DIR = "qc.fastqscreen.fastqDir";
  private static final String KEY_READ_COUNT = "run.info.read.count";
  private static final String KEY_READ_X_INDEXED = "run.info.read";
  private static final String KEY_TMP_DIR = "tmp.dir";
  private static final String COMPRESSION_EXTENSION = "fastq.bz2";

  private FastqScreen fastqscreen;
  private FastqStorage fastqStorage;
  private List<String> listGenomes = new ArrayList<String>();

  private String pathDirTest;
  private boolean paired = false;

  @Override
  public String getName() {
    return COLLECTOR_NAME;
  }

  /**
   * Collectors to execute before fastqscreen Collector
   */
  @Override
  public String[] getCollectorsNamesRequiered() {
    return new String[] {RunInfoCollector.COLLECTOR_NAME,
        DesignCollector.COLLECTOR_NAME};
  }

  /**
   * Configure fastqScreen with properties from file aozan.conf
   * @param properties
   */
  @Override
  public void configure(final Properties properties) {

    this.fastqscreen = new FastqScreen(properties);

    String tmpDir = properties.getProperty(KEY_TMP_DIR);
    this.fastqStorage = FastqStorage.getFastqStorage(tmpDir);

    System.out.println("In properties, the tmp directory is "
        + properties.get(KEY_TMP_DIR));

    pathDirTest = properties.getProperty(KEY_FASTQ_DIR);
    final Splitter s = Splitter.on(',').trimResults().omitEmptyStrings();

    for (String genome : s.split(properties.getProperty(KEY_GENOMES))) {
      this.listGenomes.add(genome);
    }
  }

  /**
   * Collect all data generated by fastqScreen for a run and update data
   * @param data RunData contain data from required collectors
   * @throws AozanException if one result collected with FastqScreen
   */
  @Override
  public void collect(final RunData data) throws AozanException {

    FastqScreenResult resultsFastqscreen = null;

    final long startTime = System.currentTimeMillis();

    // mode paired or single-end present in Rundata
    final int readCount = data.getInt(KEY_READ_COUNT);
    final boolean lastReadIndexed =
        data.getBoolean(KEY_READ_X_INDEXED + readCount + ".indexed");
    File read1 = null;
    File read2 = null;

    final int laneCount = data.getInt("run.info.flow.cell.lane.count");

    paired = readCount > 1 && !lastReadIndexed;
    System.out.println("mode paired " + paired);

    for (int read = 1; read <= readCount - 1; read++) {

      if (data.getBoolean("run.info.read" + read + ".indexed"))
        continue;

      for (int lane = 1; lane <= laneCount; lane++) {

        final List<String> sampleNames =
            Lists.newArrayList(Splitter.on(',').split(
                data.get("design.lane" + lane + ".samples.names")));

        for (String sampleName : sampleNames) {

          // Get the sample index
          final String index =
              data.get("design.lane" + lane + "." + sampleName + ".index");

          // Get project name
          final String projectName =
              data.get("design.lane"
                  + lane + "." + sampleName + ".sample.project");

          System.out.println("lane current "
              + lane + "\tsample current " + sampleName + "\tproject name "
              + projectName);

          // Set the prefix of the file
          final String prefixRead1 =
              String.format("%s_%s_L%03d_R%d_", sampleName, "".equals(index)
                  ? "NoIndex" : index, lane, read);

          final String fastqDir =
              String.format("/Project_%s/Sample_%s", projectName, sampleName);

          // Set the list of the files for the FASTQ data
          final File[] fastqFiles = createListFastqFiles(fastqDir, prefixRead1);

          if (fastqFiles == null || fastqFiles.length == 0)
            continue;

          // concatenate fastq files of one sample
          read1 = fastqStorage.getFastqFile(fastqFiles);
          
          if (read1 == null || !read1.exists())
            continue;

          if (paired) {
            // mode paired

            final String prefixRead2 =
                String.format("%s_%s_L%03d_R%d_", sampleName, "".equals(index)
                    ? "NoIndex" : index, lane, read + 1);
            final File[] fastqFilesRead2 =
                createListFastqFiles(fastqDir, prefixRead2);

            if (fastqFiles == null || fastqFilesRead2.length == 0)
              continue;

            // concatenate fastq files of one sample
            read2 = fastqStorage.getFastqFile(fastqFilesRead2);
            if (read2 == null || !read2.exists())
              continue;
          }

          // add read2 in command line
          resultsFastqscreen =
              fastqscreen.execute(read1, read2, this.listGenomes);

          if (resultsFastqscreen == null)
            throw new AozanException("Fastqscreen return no result for sample "
                + fastqDir);

          processResults(data, resultsFastqscreen, lane, sampleName, read);

          fastqStorage.removeTemporaryFastq(read1, read2);

          final long endTime = System.currentTimeMillis();
          LOGGER.info("End test with sample "
              + sampleName + " " + toTimeHumanReadable(endTime - startTime));

          System.out.println("End test with sample "
              + sampleName + " " + toTimeHumanReadable(endTime - startTime));

        } // sample
      } // lane
    } // read

    fastqStorage.clear();

  }// end method collect

  /**
   * Keep files that satisfy the specified filter in this directory and
   * beginning with this prefix
   * @param dirPath source directory
   * @param prefix prefix of file to keep
   * @return an array of abstract pathnames
   */
  private File[] createListFastqFiles(final String dirPath, final String prefix) {

    // test parameters
    // String projetTestSingle = "microbrain_A2012";
    // String projetTestPaired = "accepi_2012a";
    //
    // if (!(dirPath.contains(projetTestPaired) || dirPath
    // .contains(projetTestSingle)))
    // return null;

    return new File(pathDirTest + dirPath + "/").listFiles(new FileFilter() {

      @Override
      public boolean accept(final File pathname) {

        return pathname.length() > 0
            && pathname.getName().startsWith(prefix)
            && pathname.getName().endsWith(COMPRESSION_EXTENSION);
      }
    });
  }

  /**
   * Process results after the end of the thread.
   * @param data
   * @param result
   * @param lane
   * @param sampleName
   * @param read
   * @throws AozanException if an error occurs while generate FastqScreen
   *           results
   */
  private void processResults(final RunData data,
      final FastqScreenResult result, final int lane, final String sampleName,
      final int read) throws AozanException {

    // Set the prefix for the run data entries
    String prefix =
        "fastqscreen.lane"
            + lane + ".sample." + sampleName + ".read" + read + "."
            + sampleName;

    result.rundata(data, prefix);

    System.out.println(result.statisticalTableToString());
  }

  /**
   * Remove temporary files created in temporary directory which is defined in
   * properties of Aozan
   */
  public void clean() {

  }

  //
  // Constructor
  //

  /**
   * Public constructor for FastqScreenCollector
   */
  public FastqScreenCollector() {

  }

}
